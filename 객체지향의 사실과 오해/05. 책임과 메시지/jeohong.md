# 05. 책임과 메시지

리뷰기간: 2024년 11월 4일 → 2024년 11월 10일
태그: 작성완료

## ✨ 내용 요약

- 자율적인 책임
    - 자율적인 객체란?
        - 스스로의 의지와 판단에 따라 각자의 맡은 책임을 수행
        - 자율적인 객체 = 자율적인 책임
        - 책임임은 자율성이 보장되도록 포괄적이고 추상적이며, 해야할 일을 명확하게 명시해야함
        - `“어떻게”` 보다는 `“무엇”` 을 책임으로 사용해야함
- (너무) 추상적인 책임
    - 책임은 자율적 이여야 하지만, 협력의 의도를 표현하지 못할 수준의 추상적인 책임은 문제가 있다
    - 책임은 협력에 참여하는 의도를 명확하게 설명할 수 있는 수준 내에서 추상적이여야 한다
- 책임을 자극하는 메세지
    - 책임: 어떤 행동을 수행한다
    - 객체가 책임을 수행하게 만드는 유일한 방법은 `메세지(요청과 응답)` 이다
- 메세지와 메서드
    - 메세지
        - 메세지 : 메세지 이름 + 인자
        - 메세지 전송 : 객체가 다른 객체에 접근할 수 있는 유일한 방법
            - 메세지 전송 → 수신자와 메세지의 조합으로 이루어진다
        - 객체가 메세지를 수신한다 == 객체가 메세지에 해당하는 책임을 수행할 수 있다
        - 객체는 메세지를 처리하기 위한 방법을 `자율적` 으로 선택가능
    - 메서드
        - 메서드 : 메세지를 처리하기 위해 내부적으로 선택하는 `방법`
        - 런타임에 실행할 메서드를 선택할 수 있는 것은 객체지향의 차별점 중 하나이다.
- 다형성
    - 서로 다른 타입에 속하는 객체들이 동일 메세지를 수신 했을때 서로 다른 메서드를 통해 메세지를 처리
    - 메세지를 보낸 객체 입장에서 원하는 결과를 얻을 수 있다는 것은 다ㅏㄹ라지지 않음 ( 객체들은 동일한 책임을 공유 )
    - 다형성은 객체들을 개체 가능하게 만들고 이를 통해 재사용 가능한 유연한 설계가 가능
        - ⇒ 캡슐화의 개념 : 클라이언트는 메세지를 받는 객체의 타입을 몰라도 된다
- 송신자가 수신자에 대해 적은 정보만으로 협력이 가능하다 는 의미
    - 협력의 유연성
    - 협력 방식의 확장성
    - 협력 방식의 재사용성
- 객체지향의 핵심
    - 메세지
    - Class는 동적인 객체들의 특성과 행위를 정적인 텍스트로 표현하는 추상화 도구
    - 메세지를 통한 객체들간의 커뮤니케이션
    - 메세지가 객체를 선택 해야한다
        - 메세지 중심의 협력관계를 설계
- 책임 주도적 설계
    1. 시스템이 수행할 책임 식별
    2. 협력 관계를 시작할 적절한 객체를 찾아 책임 할당
    3. 책임 완수를 위해 다른 객체가 필요하다면 어떤 메세지가 필요한지 결정
    4. 메세지 수신에 적절한 객체를 선택하고, 수신자는 그에대한 책임을 수행
    5. 3, 4 과정을 반복하며 책임 완수
- What / Who 사이클
    - 어떤 객체가 필요한지 생각하지 말고 어떤 메세지가 필요한지 먼저 고려해야한다
    - 어떤 객체가 어떤 특성을 가지고 있다 ≠ 반드시 그와 관련된 행위를 수행할 것
- Law of Demeter
    - 어떤 객체가 수신하는지 보다 어떤 메세지를 보낼지에 더 집중할것
    - 메세지를 보내는 입장에서는 객체의 결정에 간섭할 수 없음
- 객체 인터페이스
    - 인터페이스
        - 인터페이스의 사용법만 알고 있다면 내부 구조나 동작 방법을 몰라도 상호작용 가능
        - 인터페이스가 변경되지 않고 단순히 내부 구성이나 작동 방식이 변경되는 것은 사용자에게 아무런 영향도 미치지 않는다
        - 대상이 변경되더라도 인터페이스가 동일하다면 아무런 문제 없이 기존 방식대로 상호작용 가능
    - 공용 인터페이스
        - 내부에서만 접근 가능한 인터페이스를 제외하고 외부에서도 접근 가능한 인터페이스
        - 객체의 외부와 내부를 명확하게 분리
- 객체지향적인 사고 방식을 이해하기 위한 3가지 원칙
    1. 더 추상적인 인터페이스
    2. 최소 인터페이스
    3. 인터페이스와 구현 간에 차이가 있다는 점을 인식
- 인터페이스와 구현의 분리 원칙
    - 소프트웨어는 항상 변경 되고 현 객체가 다른 객체에 영향을 주고 있는지 전부 파악하는것은 불가능
    - 내부 구현이 변경되더라도 외부 객체에 영향을 주지 않도록 `두 영역을 명확히 분리`
    - `캡슐화`를 통해 구현
- 캡슐화
    - 객체의 자율성을 보존하기 위해 구현을 외부로부터 감추는 행위
    - 상태와 행위의 캡슐화
        - 객체는 상태와 행동을 하나의 단위로 묶어서 관리
        - 반드시 외부에서 접근해야 하는 경우만 공용 인터페이스로 노출
    - 사적인 비밀의 캡슐화
        - 구현과 관련된 세부 사항을 외부로부터 감추는 것

## 📝 감상 및 리뷰

- 1장 ~ 5장 통틀어 제일 중요한 단원이라고 생각이 듦
- 다만, 반복적인 이야기를 계속 해서 너무 루즈해졌음
- 캡슐화에 대한 정확한 뜻을 알게 되었음
- 책임-주도 설계는 첫장부터 계속 나오는데 나중에 한번 명확히 찾아봐야 겠다

## 🛠️ 실무/프로젝트 적용

- 내부 인터페이스 / 외부 인터페이스를 명확히 분리하자
- 캡슐화를 잘 사용하여 재사용성을 높이자
- 내부 인터페이스를 변경 하더라도 다른 어떠한 객체에서 결과가 달라지지 않도록 구현에 주의 하자

## 🔍 추가 자료

- 더 알아보고 싶은 내용은?