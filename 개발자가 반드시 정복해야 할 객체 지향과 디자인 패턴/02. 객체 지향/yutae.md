# 절차 지향

절차지향은 프로시저 또는 함수로 프로그램을 구성하는 기법을 절차지향 프로그래밍이라고 함

절차지향은 데이터를 공유하는 방식으로 만들어지기 떄문에, 절차 지향으로 작성하면 프로그램이 데이터 중심으로 구성이됨.

### 장점

데이터 중심적이라 데이터가 적은 초기에는 구현하기 쉬움

### 단점

프로그램이 거대해지면서 데이터나 사용하는 프로시저가 많아져 같은 데이터를 프로시저들 끼리 다른 의미로 사용하는 경우도 발생하고 유지보수가 힘들어짐

# 객체 지향

객체 지향은 데이터와  관련된 프로시저를 객체라는 단위로 묶으며 객체들이 모여 프로그램을 구성함

### 장점

객체는 자신만의 기능을 제공하며, 각 객체들은 서로 연결되어 다른 객체가 제공하는 기능을 사용할 수 있음

데이터나 로직이 수정 될 때 해당 기능을 담당하는 객체만 수정하면 되서 다른 객체에 영향을 주지 않음.

### 단점

설계가 어려워 설계가  한번에 완성되는 경우는 없고 개발이 진행되면서 점진적으로 완성이됨

## 인터페이스

특정 객체가 제공하는 모든 오퍼레이션 또는 메서드를  `인터페이스(interface)`라고 부름

인터페이스는 객체가 제공하는 기능에 대한 명세이며, 인터페이스를 상속한 객체는 해당 명세를 구현해야함

## 메세지

객체 지향에서 다른 객체의 오퍼레이션을 실행을 요청(request)하는것을 메세지를 보낸다 라고 표현함 

따라서 객체 오퍼레이션 끼리 주고 받는것을 메세지라 할 수 있음

# 객체의 책임과 크기

객체는 객체마다 자신만의 책임을 가지고 있으며 이를 정의하기위해서 타입/인터페이스를 사용함

객체는 작아야하며 하나의 책임만 가져야하는데 객체가 커지고 기능을 많은 기능을 책임지게 된다면 절차 지향이랑 다를게 없어져서 유지보수가 어려워질 수 있음

`SRP(단일책임원칙)`  을 따라 객체는 하나의 책임만 가져야함.

# 의존

다른 객체의 기능을 이용하여 자신의 기능을 완성 시키는걸 다른 객체를 `의존` 한다고 함.

```java
public class Flow() {
	
	private final Some some;

	public Flow(Some some) {
		this.some =	some;
	}
	
	public process() {
		// do someting 
		this.some.doSometing();
	}
}
```

위 Flow객체는 Some 객체의 오퍼레이션을 이용해서 자신의 process()라는 오퍼레이션을 완성 시켰다면 이는 Flow객체는 Some 객체를 의존한다고 보면됨.

또는 위처럼 생성하거나 메서드를 호출하는 것 뿐만 아니라 파라미터로 전달받는 경우에도 의존한다고 볼 수 있음

의존이라는걸 하게된다면 의존하는 객체나 프로시저가 변경 될 경우 나 자신까지 변경될 가능성이 있다고 보면됨.

## 순환 참조

```java
public class Flow() {
	
	private final Some some;

	public Flow(Some some) {
		this.some =	some;
	}
	
	public process() {
		// do someting 
		this.some().doSometing();
	}
}

public class Some() {
	private final Flow flow;
	
	// something 
}
```

위 처럼 두개 이상의 객체나 모듈이 서로를 참조 또는 의존하고  있는걸 `순환 참조`라함 

순환 참조를 하게될 경우 메모리 누수나 버그를 유발 할 수 있으므로 순환 참조가 발생하게 된다면 적극적으로 해소하는게 좋음

# 캡슐화

캡슐화는 객체가 내부적으로 기능을 어떻게 구현했는지를 외부에 감추는 것을 말한다.

이를 통해 다른 객체는 해당 객체를 사용할 때 내부 구현 방식을 몰라도 되고,

만약 내부 로직이 변경되더라도 해당 객체의 코드만 수정하면 되며, 이를 사용하는 다른 객체들의 코드는 변경할 필요가 없다.